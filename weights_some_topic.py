# -*- coding: utf-8 -*-
"""weights_some_topic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X9FjNF-R4VsIUQs9UESZw7-IZEI5SNlg

# Сейчас мы запустим этот тестовый ноутбук!
"""

import pandas as pd
import numpy as np
import csv







print ("Введите желаемое количество социальных агентов")
n = int(input())

import random
country = list(range(n))
year = ["2021"] * n
ppc = [random.uniform(0, 100) for _ in range(n)]
unnamed = ["" for _ in range(n)]
Topic1 = [random.uniform(0, 1) for _ in range(n)]
Topic2 = [random.uniform(0, 1) for _ in range(n)]
Topic3 = [random.uniform(0, 1) for _ in range(n)]
Topic4 = [random.uniform(0, 1) for _ in range(n)]
Topic5 = [random.uniform(0, 1) for _ in range(n)]
Topic6 = [random.uniform(0, 1) for _ in range(n)]
Topic7 = [random.uniform(0, 1) for _ in range(n)]
Topic8 = [random.uniform(0, 1) for _ in range(n)]
Topic9 = [random.uniform(0, 1) for _ in range(n)]
df2 = pd.DataFrame({'country': country, 'year': year, 'ppc': ppc, 'Unnamed': unnamed, 'Topic1': Topic1,"Topic2":Topic2,"Topic3":Topic3,"Topic4":Topic4,"Topic5":Topic5,"Topic6":Topic6,"Topic7":Topic7,"Topic8":Topic8,"Topic9":Topic9})
print(df2.head())

df2.to_csv('climate_norm.csv', sep=';', index=False)

communication_data

data = communication_data
df = pd.DataFrame(data)

TOP_counts = df['SelectedTopic'].value_counts()

print(TOP_counts)





import collections

import statistics
import matplotlib.pyplot as plt


def quantiles(l, n=0, method=''):
    l.sort()
    r = []
    for i in range(n):
        r.append(l[len(l)*i//n])
    r.append(l[-1])
    return r

statistics.quantiles = quantiles

class Opinion:
    def __init__(self, topics):
        self.topics = topics  # Мнения агента по различным темам

    def clone(self):
        return Opinion(self.topics[:])

    def diff(self, o, topic):
        return self.topics[topic] - o.topics[topic]

    def communicate(self, o, pow1, pow2, topic):
        diff = self.diff(o, topic)
        abs_diff = abs(diff)
        k = 1 - abs_diff
        K = 0.1
        speed = diff * k / 2 * K
        k2 = 1
        if pow1 > pow2:
            divis = abs(speed) * (1 - (pow2 / pow1))
            diff1 = abs(speed) - k2 * divis
            diff2 = abs(speed) + k2 * divis
        elif pow2 > pow1:
            divis = abs(speed) * (1 - (pow1 / pow2))
            diff1 = abs(speed) + k2 * divis
            diff2 = abs(speed) - k2 * divis
        else:
            diff1 = abs(speed)
            diff2 = abs(speed)

        if speed < 0:
            diff1 = 0 - diff1
            diff2 = 0 - diff2

        new_op1 = self.clone()
        new_op2 = o.clone()
        new_op1.topics[topic] -= diff1
        new_op2.topics[topic] += diff2
        return new_op1, new_op2

    def replaceWithAverage(self, opinions):
        s = [0] * len(self.topics)
        c = 0
        for o in opinions:
            for i in range(len(self.topics)):
                s[i] += o.topics[i]
            c += 1
        for i in range(len(self.topics)):
            self.topics[i] = s[i] / c

class Connection:
    def __init__(self, person, strength, topic):
        self.person = person
        self.strength = strength
        self.topic = topic

    def active(self):
        return random.random() < self.strength

class Person:
    def __init__(self, num_topics):
        self.connections = []
        self.opinions = Opinion([random.random() for _ in range(num_topics)])
        self.power = random.random()
        self.prof = 0.5
        self.prof2 = 0

    def addConnection(self, connection):
        self.connections.append(connection)

    def communicate(self):
        new_ops = []
        self.prof2 = self.prof
        K = 1
        for c in self.connections:
            p2 = c.person
            topic = c.topic
            if c.active():
                new_op1, new_op2 = self.opinions.communicate(p2.opinions, self.power, p2.power, topic)
                new_ops.append((p2, topic, new_op1, new_op2))

                K2 = (1 - self.prof)
                diff = abs(self.opinions.diff(p2.opinions, topic))
                k = ((1 - diff) * 10 - 8.5)
                dopstrength = c.strength
                if k < 0:
                    speed = k * c.strength * K
                    speed += (K2 * speed)
                    c.strength += speed
                else:
                    speed = k * (1 - c.strength) * K
                    speed -= (K2 * speed)
                    c.strength += speed

                self.prof2 += (dopstrength - c.strength)
                if self.prof2 < 0:
                    self.prof2 = 0.00000000000000001
                if self.prof2 > 1:
                    self.prof2 = 0.99

        return new_ops

    def updateConnections(self):
        self.prof = self.prof2

def load_communication_data(filename):
    communication_data = pd.read_csv(filename)
    return communication_data

def randomOpinion(num_topics):
    topics = [random.random() for _ in range(num_topics)]
    return Opinion(topics)

def cycle(people, communication_data):
    ops = []
    for p in people:
        ops.append((p, p.communicate()))

    m = collections.defaultdict(list)
    for p, new_ops in ops:
        for p2, topic, x, y in new_ops:
            m[id(p2)].append((topic, y))
            m[id(p)].append((topic, x))

    for p in people:
        if id(p) in m:
            assert m[id(p)]
            p.opinions.replaceWithAverage([opinion for topic, opinion in m[id(p)]])

    for p in people:
        p.updateConnections()

def round_list(l, n):
    return [round(x, n) for x in l]

def stats2(people, x, num_topics):
    opinions_numbers = [[] for _ in range(num_topics)]
    connections_strengths = []
    for p in people:
        for topic, opinion in enumerate(p.opinions.topics):
            opinions_numbers[topic].append(opinion)  # Собираем мнения агентов по разным темам
        connections_strengths.append(sum([c.strength for c in p.connections]) / len(p.connections))

    topics_data = {}
    for topic in range(num_topics):
        opinions_topic = opinions_numbers[topic]
        min_opinion = min(opinions_topic)
        max_opinion = max(opinions_topic)
        mean_opinion = statistics.mean(opinions_topic)
        median_opinion = statistics.median(opinions_topic)
        std_deviation = statistics.stdev(opinions_topic)

        topics_data[f"Topic {topic + 1}"] = [min_opinion, max_opinion, mean_opinion, median_opinion, std_deviation]

    connections_min = min(connections_strengths)
    connections_max = max(connections_strengths)
    connections_mean = statistics.mean(connections_strengths)
    connections_median = statistics.median(connections_strengths)
    connections_std_deviation = statistics.stdev(connections_strengths)

    topics_data["Connections"] = [connections_min, connections_max, connections_mean, connections_median,
                                  connections_std_deviation]

    table = pd.DataFrame(topics_data, index=["Min", "Max", "Mean", "Median", "Std Deviation"]).T

    return table

# Загрузка данных о мнениях агентов и коммуникации
climdata = pd.read_csv('climate_norm.csv', sep=';')
num_topics = 9  # Количество тем
people = [Person(num_topics) for _ in range(climdata.shape[0])]

communication_data = load_communication_data('communication_results.csv')

# Создание связей между агентами
counttrade = 0
for p1 in range(len(people)):
    for p2 in range(len(people)):
        if p1 != p2:
            agent_id_1 = p1  # Замените на реальный способ получения AgentId1
            agent_id_2 = p2  # Замените на реальный способ получения AgentId2
            selected_topic = communication_data[
                ((communication_data['AgentId1'] == agent_id_1) & (communication_data['AgentId2'] == agent_id_2)) |
                ((communication_data['AgentId1'] == agent_id_2) & (communication_data['AgentId2'] == agent_id_1))
            ]['SelectedTopic'].values[0]
            selected_topic = selected_topic - 1  # Вычитаем 1, так как индексы начинаются с 0
            people[p1].addConnection(Connection(people[p2], 0.01, selected_topic))


for i in range(5):
    print(i)
    cycle(people, communication_data)
    table = stats2(people, climdata['country'].tolist(), num_topics)

    if (i == 10) or (i == 50) or (i == 99) or (i == 0) or (i == 150) or (i == 199) or (i == 500) or (i == 999):
        table.to_csv(str(i) + '_stats.csv', sep=';')

    # Создание таблицы связей между агентами
    connections_data = []
    for person in people:
        for connection in person.connections:
            connections_data.append({
                'Agent1': people.index(person),
                'Agent2': people.index(connection.person),
                'Strength': connection.strength,
                'Topic': connection.topic
            })
    connections_df = pd.DataFrame(connections_data)
    connections_df.to_csv(f'connections_{i}.csv', sep=';', index=False)

    # Создание графиков мнений по каждой теме
    for topic_idx in range(num_topics):
      topic_opinions = [person.opinions.topics[topic_idx] for person in people]
      plt.hist(topic_opinions, bins=40, range=(0.0, 1.0))
      plt.xlabel('Opinion')
      plt.ylabel('Frequency')
      plt.title(f'Opinion Distribution for Topic {topic_idx + 1} at Iteration {i}')
      plt.savefig(f'opinions_graphic_{topic_idx + 1}_iteration_{i}.png')
      plt.clf()

print("Done.")

data = pd.read_csv('/content/connections_499.csv', delimiter=';')

data

data = data.drop(columns=['Topic'])

matrix = data.pivot(index='Agent1', columns='Agent2', values='Strength')

matrix.to_csv('matrix.csv', sep=';')

matrix

import shutil
import os

os.makedirs('Data')

file_path = '/content/opinions_graphic_9_iteration_199.png'

destination_folder = '/content/Data'

shutil.move(file_path, destination_folder)

data = list(range(100))

df = pd.DataFrame(data, columns=["Id"])

df["Opinion"] = 1
df.to_csv("table.csv", index=False)
print(df)

file_path = '/content/table.csv'

destination_folder = '/content/Data'

shutil.move(file_path, destination_folder)

import pandas as pd

df = pd.read_csv('/content/connections_50.csv', sep = ";")


df.rename(columns={'Agent1': 'Source', 'Agent2': 'Target', 'Strength': 'Color'}, inplace=True)

df.insert(df.columns.get_loc('Color'), 'Weight', 1)


df['Type'] = 'undirected'
df = df.drop(columns=['Topic'])



df.to_csv('Prematrix.csv', index=False)

print(df)

df = df[df['Color'] >= 0.1]

df.to_csv("Connections.csv", sep = ";", index = False)

agents = df['Source'].unique()
for agent in agents:
    df = df.append({'Source': agent, 'Target': agent, 'Weight': 0, 'Color': 0, 'Type': 'undirected'}, ignore_index=True)
print(df)

df



file_path = '/content/Connections.csv'

destination_folder = '/content/Data'

shutil.move(file_path, destination_folder)

matrix = df.pivot(index='Source', columns='Target', values='Color')

matrix.to_csv("matrix2.csv", sep = ";")

file_path = '/content/matrix2.csv'

destination_folder = '/content/Data'

shutil.move(file_path, destination_folder)